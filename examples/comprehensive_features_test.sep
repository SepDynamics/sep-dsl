// Comprehensive test demonstrating async/await and exception handling

// Async function that processes sensor data  
async function processSensorData(sensor_id) {
    try {
        // Simulate async data fetching with await
        entropy_value = await measure_entropy(sensor_id)
        coherence_value = await measure_coherence(sensor_id)
        
        // Check for anomalies
        if (entropy_value > 0.8) {
            throw "High entropy detected in sensor " + sensor_id
        }
        
        return entropy_value + coherence_value
    }
    catch (error) {
        error_log = "Sensor processing failed: " + error
        return -1
    }
    finally {
        cleanup_log = "Sensor " + sensor_id + " processing completed"
    }
}

// Regular function for comparison
function processBasicData(data_id) {
    return measure_entropy(data_id)
}

// Pattern demonstrating nested exception handling with async
pattern anomaly_detection {
    try {
        // Test normal processing
        normal_result = await processSensorData("sensor_001")
        
        try {
            // Test error condition
            anomaly_result = await processSensorData("high_entropy_sensor")
            
            // This should trigger an exception
            if (anomaly_result == -1) {
                throw "Anomaly detected in processing pipeline"
            }
        }
        catch (inner_error) {
            inner_handling = "Inner exception caught: " + inner_error
            
            // Re-throw with more context
            throw "Pipeline failure: " + inner_error
        }
    }
    catch (outer_error) {
        final_error_handling = "System error: " + outer_error
        system_status = "degraded"
    }
    finally {
        // This always executes
        system_timestamp = "2025-08-03T00:00:00Z"
        processing_complete = "true"
    }
}

// Pattern with direct await usage
pattern direct_async_analysis {
    // Direct await without function call
    direct_entropy = await measure_entropy("direct_test")
    direct_coherence = await measure_coherence("direct_test")
    
    // Combined async result
    combined_metric = direct_entropy * direct_coherence
}

// Error handling pattern  
pattern error_recovery {
    retry_count = 0
    max_retries = 3
    
    try {
        // Simulate a process that might fail
        throw "Simulated failure"
    }
    catch (failure) {
        recovery_message = "Recovered from: " + failure
        fallback_value = 0.5
    }
}

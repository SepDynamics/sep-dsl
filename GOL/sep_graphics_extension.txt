// Proposed graphics extension for SEP DSL stdlib
// This would go in src/dsl/stdlib/graphics/graphics.cpp

#include "graphics.h"
#include "src/dsl/runtime/value.h"
#include "src/dsl/runtime/interpreter.h"
#include <iostream>
#include <vector>
#include <sstream>

namespace dsl {
namespace stdlib {
namespace graphics {

// ANSI color codes for terminal graphics
const std::string RESET = "\033[0m";
const std::string BLACK = "\033[30m";
const std::string RED = "\033[31m";
const std::string GREEN = "\033[32m";
const std::string YELLOW = "\033[33m";
const std::string BLUE = "\033[34m";
const std::string MAGENTA = "\033[35m";
const std::string CYAN = "\033[36m";
const std::string WHITE = "\033[37m";

// Background colors
const std::string BG_BLACK = "\033[40m";
const std::string BG_RED = "\033[41m";
const std::string BG_GREEN = "\033[42m";
const std::string BG_YELLOW = "\033[43m";
const std::string BG_BLUE = "\033[44m";
const std::string BG_MAGENTA = "\033[45m";
const std::string BG_CYAN = "\033[46m";
const std::string BG_WHITE = "\033[47m";

// Terminal control
const std::string CLEAR = "\033[2J\033[H";
const std::string HIDE_CURSOR = "\033[?25l";
const std::string SHOW_CURSOR = "\033[?25h";

// Virtual screen buffer
class ScreenBuffer {
private:
    int width;
    int height;
    std::vector<std::vector<char>> chars;
    std::vector<std::vector<std::string>> colors;
    
public:
    ScreenBuffer(int w, int h) : width(w), height(h) {
        chars.resize(height, std::vector<char>(width, ' '));
        colors.resize(height, std::vector<std::string>(width, ""));
    }
    
    void setPixel(int x, int y, char c, const std::string& color) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
            chars[y][x] = c;
            colors[y][x] = color;
        }
    }
    
    void clear() {
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                chars[y][x] = ' ';
                colors[y][x] = "";
            }
        }
    }
    
    std::string render() {
        std::stringstream ss;
        ss << CLEAR;  // Clear screen
        
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                ss << colors[y][x] << chars[y][x] << RESET;
            }
            ss << "\n";
        }
        
        return ss.str();
    }
};

// Global screen buffer (would be better as part of interpreter state)
static std::unique_ptr<ScreenBuffer> screen = nullptr;

// Initialize graphics system
Value init_graphics(const std::vector<Value>& args) {
    if (args.size() != 2) {
        throw std::runtime_error("init_graphics expects 2 arguments: width, height");
    }
    
    int width = static_cast<int>(args[0].get<double>());
    int height = static_cast<int>(args[1].get<double>());
    
    screen = std::make_unique<ScreenBuffer>(width, height);
    std::cout << HIDE_CURSOR;
    
    return Value(true);
}

// Clear the screen
Value clear_screen(const std::vector<Value>& args) {
    if (!screen) {
        throw std::runtime_error("Graphics not initialized. Call init_graphics() first.");
    }
    
    screen->clear();
    return Value(true);
}

// Draw a colored character at position
Value draw_char(const std::vector<Value>& args) {
    if (args.size() < 3) {
        throw std::runtime_error("draw_char expects at least 3 arguments: x, y, char, [color]");
    }
    
    if (!screen) {
        throw std::runtime_error("Graphics not initialized. Call init_graphics() first.");
    }
    
    int x = static_cast<int>(args[0].get<double>());
    int y = static_cast<int>(args[1].get<double>());
    std::string charStr = args[2].get<std::string>();
    
    std::string color = WHITE;  // Default color
    if (args.size() >= 4) {
        std::string colorName = args[3].get<std::string>();
        if (colorName == "red") color = RED;
        else if (colorName == "green") color = GREEN;
        else if (colorName == "blue") color = BLUE;
        else if (colorName == "yellow") color = YELLOW;
        else if (colorName == "magenta") color = MAGENTA;
        else if (colorName == "cyan") color = CYAN;
        else if (colorName == "white") color = WHITE;
        else if (colorName == "black") color = BLACK;
    }
    
    screen->setPixel(x, y, charStr[0], color);
    return Value(true);
}

// Draw a filled rectangle
Value draw_rect(const std::vector<Value>& args) {
    if (args.size() < 4) {
        throw std::runtime_error("draw_rect expects at least 4 arguments: x, y, width, height, [char], [color]");
    }
    
    if (!screen) {
        throw std::runtime_error("Graphics not initialized. Call init_graphics() first.");
    }
    
    int x = static_cast<int>(args[0].get<double>());
    int y = static_cast<int>(args[1].get<double>());
    int width = static_cast<int>(args[2].get<double>());
    int height = static_cast<int>(args[3].get<double>());
    
    char fillChar = '#';
    if (args.size() >= 5) {
        fillChar = args[4].get<std::string>()[0];
    }
    
    std::string color = WHITE;
    if (args.size() >= 6) {
        std::string colorName = args[5].get<std::string>();
        if (colorName == "red") color = RED;
        else if (colorName == "green") color = GREEN;
        else if (colorName == "blue") color = BLUE;
        else if (colorName == "yellow") color = YELLOW;
        else if (colorName == "magenta") color = MAGENTA;
        else if (colorName == "cyan") color = CYAN;
        else if (colorName == "white") color = WHITE;
        else if (colorName == "black") color = BLACK;
    }
    
    for (int dy = 0; dy < height; dy++) {
        for (int dx = 0; dx < width; dx++) {
            screen->setPixel(x + dx, y + dy, fillChar, color);
        }
    }
    
    return Value(true);
}

// Present the screen buffer to terminal
Value present_screen(const std::vector<Value>& args) {
    if (!screen) {
        throw std::runtime_error("Graphics not initialized. Call init_graphics() first.");
    }
    
    std::cout << screen->render() << std::flush;
    return Value(true);
}

// Cleanup graphics
Value cleanup_graphics(const std::vector<Value>& args) {
    std::cout << SHOW_CURSOR << CLEAR;
    screen.reset();
    return Value(true);
}

// Sleep for milliseconds (for frame rate control)
Value sleep_ms(const std::vector<Value>& args) {
    if (args.size() != 1) {
        throw std::runtime_error("sleep_ms expects 1 argument: milliseconds");
    }
    
    int ms = static_cast<int>(args[0].get<double>());
    std::this_thread::sleep_for(std::chrono::milliseconds(ms));
    return Value(true);
}

// Register all graphics functions
void register_graphics(Runtime& runtime) {
    runtime.register_function("init_graphics", init_graphics);
    runtime.register_function("clear_screen", clear_screen);
    runtime.register_function("draw_char", draw_char);
    runtime.register_function("draw_rect", draw_rect);
    runtime.register_function("present_screen", present_screen);
    runtime.register_function("cleanup_graphics", cleanup_graphics);
    runtime.register_function("sleep_ms", sleep_ms);
}

} // namespace graphics
} // namespace stdlib
} // namespace dsl
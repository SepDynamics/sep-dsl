// Conway's Game of Life implemented in SEP DSL
// This serves as a foundation for a larger game engine

// Grid dimensions
pattern game_config {
    width = 20
    height = 10
    grid_size = width * height
}

// Initialize a grid with a glider pattern
pattern initialize_grid {
    // Create flat array to simulate 2D grid
    grid = []
    
    // Initialize all cells to dead (0)
    i = 0
    while (i < game_config.grid_size) {
        grid = grid + [0]
        i = i + 1
    }
    
    // Place a glider at position (5, 5)
    // Glider pattern:
    //   X
    // X X
    //  XX
    grid[5 * game_config.width + 6] = 1    // (5, 6)
    grid[6 * game_config.width + 4] = 1    // (6, 4)
    grid[6 * game_config.width + 6] = 1    // (6, 6)
    grid[7 * game_config.width + 5] = 1    // (7, 5)
    grid[7 * game_config.width + 6] = 1    // (7, 6)
}

// Convert 2D coordinates to 1D array index
function coord_to_index(x: Number, y: Number): Number {
    return y * game_config.width + x
}

// Get cell value with boundary wrapping
function get_cell(grid: Array, x: Number, y: Number): Number {
    // Implement toroidal topology (wrap around edges)
    wrapped_x = (x + game_config.width) % game_config.width
    wrapped_y = (y + game_config.height) % game_config.height
    
    index = coord_to_index(wrapped_x, wrapped_y)
    return grid[index]
}

// Count living neighbors for a cell
function count_neighbors(grid: Array, x: Number, y: Number): Number {
    count = 0
    
    // Check all 8 neighboring cells
    dx = -1
    while (dx <= 1) {
        dy = -1
        while (dy <= 1) {
            // Skip the center cell
            if (dx != 0 || dy != 0) {
                neighbor_x = x + dx
                neighbor_y = y + dy
                count = count + get_cell(grid, neighbor_x, neighbor_y)
            }
            dy = dy + 1
        }
        dx = dx + 1
    }
    
    return count
}

// Apply Conway's rules to determine next state
function apply_rules(current_state: Number, neighbor_count: Number): Number {
    // Rules:
    // 1. Any live cell with 2 or 3 neighbors survives
    // 2. Any dead cell with exactly 3 neighbors becomes alive
    // 3. All other cells die or stay dead
    
    if (current_state == 1) {
        if (neighbor_count == 2 || neighbor_count == 3) {
            return 1  // Survives
        } else {
            return 0  // Dies
        }
    } else {
        if (neighbor_count == 3) {
            return 1  // Birth
        } else {
            return 0  // Stays dead
        }
    }
}

// Evolve the grid one generation
pattern evolve_grid {
    input: current_grid
    
    // Create new grid for next generation
    next_grid = []
    
    y = 0
    while (y < game_config.height) {
        x = 0
        while (x < game_config.width) {
            // Get current cell state
            index = coord_to_index(x, y)
            current_state = current_grid[index]
            
            // Count neighbors
            neighbors = count_neighbors(current_grid, x, y)
            
            // Apply rules
            next_state = apply_rules(current_state, neighbors)
            
            // Add to next grid
            next_grid = next_grid + [next_state]
            
            x = x + 1
        }
        y = y + 1
    }
    
    result = next_grid
}

// Display the grid as ASCII art
function display_grid(grid: Array) {
    print("Generation:")
    print("+" + "—" * game_config.width + "+")
    
    y = 0
    while (y < game_config.height) {
        row = "|"
        x = 0
        while (x < game_config.width) {
            index = coord_to_index(x, y)
            if (grid[index] == 1) {
                row = row + "■"
            } else {
                row = row + " "
            }
            x = x + 1
        }
        row = row + "|"
        print(row)
        y = y + 1
    }
    
    print("+" + "—" * game_config.width + "+")
}

// Analyze grid patterns using SEP DSL's AGI functions
pattern analyze_life_patterns {
    input: grid
    
    // Convert grid to string for pattern analysis
    grid_string = ""
    i = 0
    while (i < game_config.grid_size) {
        grid_string = grid_string + grid[i]
        i = i + 1
    }
    
    // Use built-in AGI functions for analysis
    entropy = measure_entropy(grid_string)
    coherence = measure_coherence(grid_string)
    
    // Detect stable patterns (low entropy, high coherence)
    if (entropy < 0.3 && coherence > 0.7) {
        pattern_type = "Stable (still life or oscillator)"
    } else if (entropy > 0.7) {
        pattern_type = "Chaotic"
    } else {
        pattern_type = "Evolving"
    }
    
    print("Pattern Analysis:")
    print("  Entropy:", entropy)
    print("  Coherence:", coherence)
    print("  Pattern Type:", pattern_type)
}

// Main game loop
pattern game_of_life {
    // Initialize
    initialize_grid()
    current_grid = initialize_grid.grid
    
    print("=== Conway's Game of Life ===")
    print("Grid:", game_config.width, "x", game_config.height)
    print("")
    
    // Run for 10 generations
    generation = 0
    while (generation < 10) {
        print("Generation", generation)
        display_grid(current_grid)
        
        // Analyze patterns every 5 generations
        if (generation % 5 == 0) {
            analyze_life_patterns(current_grid)
        }
        
        // Evolve to next generation
        evolve_grid(current_grid)
        current_grid = evolve_grid.result
        
        print("")  // Empty line between generations
        generation = generation + 1
    }
    
    print("Simulation complete!")
}

// Extension point: Game engine foundation
pattern game_engine_core {
    // This pattern demonstrates how Game of Life
    // can be extended into a full game engine
    
    // Entity system (each cell could be an entity)
    entities = []
    
    // Event system placeholder
    events = []
    
    // Physics placeholder (for future particle systems)
    physics_enabled = false
    
    // Render system (currently ASCII, could be extended)
    renderer = "ascii"
    
    print("Game Engine Core initialized")
    print("- Entity system: ready")
    print("- Event system: ready") 
    print("- Physics: disabled")
    print("- Renderer:", renderer)
}

// Run the game
pattern main {
    game_engine_core()
    print("")
    game_of_life()
}